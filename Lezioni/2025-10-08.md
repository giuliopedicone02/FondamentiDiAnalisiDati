# Mercoledì 08 ottobre 2025

Riprendere le prime 10 slides

## Scale di misura

Le variabili possono essere caratterizzati per lel oro scale di valori

- Scala nominale: Variabili qualitative come i colori non sono ordinabili naturalmente
- Scala ordinale: Le varfiabioli possono essere ordinabili, le differenze non sono significative. Esempio: Livello di soddisfazione (poco soddisfatto, molto soddisfatto)
- Intervallo: Valori ordinabili ma le differenze sono significative, non esiste uno zero assoluto. Zero non significa assenza di quantità che sto misurando, ad esempio la temperatura a 0 gradi non significa assenza di temperatura, esistono infatti le temperature negative.
- Ratio: Valori ordinabili, esiste uno zero assoluto ad esempio l'altezza o il denaro. Il regressore lineare asssume le sue ariabili di tipo ratio.

## Dataset e Design Matrix

Quando acquisico dei dati l'acquisizione che faccio si chiama dataset, è generalmente rappresentato come una tabella chiamata design matrix, ogni riga sarà una osservazione diversa, ogni colonna una variabile diversa.

Il processo di acquisizione dei dati non è quasi mai pulito, specialmente quelle effettuate in maniera non automatizzata. Possiamo trovare:

- Missing values: Valori mancanti da codificiare in maniera opportuna (NaN = Not a Number)
- Errori: Valori fuori range per errore, come errori di trascrizione o anomalia

## Come acquisiamo i dati? Data Collection

Possiamo acquisire dati tramite:
- Sondaggi: Cartacei o online, se ben strutturati posso avere dati abbastanza puliti ma molto lungo da acquisire
- Esperimenti: Fare esperimenti in un ambiente controllato, se volessi capire se un farmaco funziona correttamente prendo un gruppo di persone lo divido in due ai primi somministro il farmaco ai secondi no ed analizzo le conseguenze. Permettono di stabilire rapporti di causa-effetto. Tipo Principale: Randomised Controlled Trials, i problemi sono due: costi ed etica
- Ossservazionale: Consiste nel raccogliere dati così come sono senza alcun tipo di ricerca, sono difficili da analizzare.
- Piattaforme online: Kaggle ad esempio che mette a disposizione dataset, UCI Repository più incentrato al lato machine learning, APIs di Social Media e Web Scraping

## Note sul notebook di laboratorio

- PassengerID: Variabile numerica ordinale
- Survived: Variabile numerica ordinale di tipo qualitativo, categorica e binaria
- Pclass: Variabile numerica ordinale, non è sicuramrnte ratio
- Name: Variabile qualitativa nominale
- Sex: Variabile nominale non ordinale
- Age: Variabile numerica quantitativa discreta
- Sibsp: (numero di fratelli o sorelle/coniugi indica se è stato imborcato insieme alla famiglia) variabile discreta numerica quntitativa ordinabile esiste uno zero
- Parch (numero di genitori/bambini a bordo del titanic) come sopra
- Ticket: Variabile nominale
- Fare: Variabile numerica continua di tipo ratio zero vuol dire che non ha pagato
- Cabin: Variabile nominale
- Embarked: Variabile qualitativa discreta

Il valore cabin è NaN spesso quando la classe è seconda o terza, probabilmente non avevano un numero di cabina.

`titanic.info()` ci restituisce una lista contenente i tipi delle variabili memorizzate nel dataset e gli elementi non nulli per ogni colonna

`titanic.index` resitutisce il vettore degli indici il cui nome è PassengerID+d

Se volessi andare a richiamare una specifica riga posso farlo tramite `titanic.loc[index]` dove index è l'indice del passeggero che voglio visualizzare. Posso anche visualizzare uno specifico valore con `titanic.loc[index]['Attribute']`. 

Con `iloc` bypasso gli indici e considero l'ordinamento del dataset quindi ad esempio iloc[101] restituisce la 102esima riga, utile se l'indice è una stringa e volessi visualizzare il quinto elemento senza sapere il suo index.

Per estrarre una colonna posso utilizzare `titanic['Attribute']`

## Data Wrangling

Serie di tecniche che servono per trasformare i dati in formato più utile per i nostri scopi. Le tecniche tipiche sono capire cosa fare con i valori mancanti, convertire dei tipi di dati, creare nuove features, filtrare per ottenere sottoinsiemi.

## Gestire i valori mancanti

Due modi:
- dropna: Rimuove tutte le righe che contengono almeno un valore mancante (richiamando info tutti gli attributi avranno lo stesso counter)
-fillna: Sostituire i valori mancanti con un valore arbitrario, ad esempio dove manca l'età lo sostituiamo con la media delle età dei passeggeri `titanic['Age'].fillna(titanic['Age'].mean())`

## Convertire i tipi di dati

`titanic['Age'].dtype` ci restituisce il tipo della variabile. Con `titanic['Age'].astype('category')` possiamo trasformare una variabile in categorica e non numerica. Possiamo inoltre scegliere di rinominare le colonne `titanic.rename(columns={'SibSp': 'SiblingsSpouses'}, inplace=True)`, inplace=True significa che le modifiche sovrascriveranno la vecchia versione senza effettuare l'assegnamento

## Creazione di nuove features (Features Engineering)

Creiamo una nuova colonna o feature che è combinazione di altre features:

```python
titanic2['FamilySize'] = titanic2['SiblingsSpouses'] + titanic2['Parch']
titanic2.info()
```

Può sembrare una buona idea ma non sempre lo è, se serve trovare l'inversa di una matrice potrebbero esserci problemi con il rango

## Filtraggio

Possiamo farlo tramite indicizzazione dinamica

```python
titanic2 = titanic2[titanic2['Age'] >= 18]
titanic2.info()
```

Possiamo anche eliminare delle colonne con `.drop()` o mostrare solo alcune colonne `titanic2[['Age', 'Cabin', 'Fare']].head()`

## Formato Lungo (Long) VS Formato Largo (Wide)

Nel formato wide:
- Ogni variabile ha una sua colonna
- Ogni osservazione è una riga
- Facile da leggere, struttura intuitiva  

Nel formato long:
- Le variabili sono distribuite in più colonne
- Ogni osservazione è presente in più righe

```python
# Example: Wide vs Long format

# Create sample data in wide format
wide_data = pd.DataFrame({
    'Student': ['Alice', 'Bob', 'Charlie'],
    'Math': [85, 92, 78],
    'Science': [88, 85, 92],
    'English': [92, 88, 85]
})

print("Wide Format:")
print(wide_data)

# Convert to long format
long_data = pd.melt(wide_data, 
                   id_vars=['Student'], 
                   var_name='Subject', 
                   value_name='Score')

print("\nLong Format:")
print(long_data)

# Convert back to wide format
wide_again = long_data.pivot(index='Student', columns='Subject', values='Score')
print("\nBack to Wide Format:")
print(wide_again)
```

## Workflow della Data Analysis

1. Ci si pone una domanda sull'analisi dei dati
2. Acquisico dei dati
3. Devo formattarli e pulirli
4. Esploro e descrivo i dati
5. Scelgo un modello (regressore lineare)
6. Valuto e confronto i modelli
7. Revisiono i dati quando saranno disponibili

# Lezione 3 - Descrivere e Visualizzare i Dati

Abbiamo visto come accedere ai dati vogliamo adesso descrivere e visualizzare le informazioni contenute nel dataset per poi poter applicare un modello su essi.

Campione univariato: Campione che prevede un solo elemento di variabilità

## Frequenze

I valori univoci (calcolabili tramite il metodo `.unique()`)senza ripetizioni prendono il nome di $a_1...a_n$ mentre $n_i$ è il numero di volte che quel valore si presenta

$$
\sum_i(n_i) = N
$$

Le frequenze assolute è possibile calcolarle con `value_counts()` ordinati di default per frequenza, ma è possibili ordinarli per indice tramite `value_counts().sort_index()`

Si denota una forma Gaussiana, i valori centrali hanno molte occorrenze quelli finali molto meno. Possiamo mostrare i grafici tramite un grafico a barre delle frequenze assolute. Sull'asse delle x abbiamo i valori unici, sull'asse delle y il numero di ripetizioni.

## Frequenze Relative

Le ottengo dividendo tutte le frequenze per il numero totale di elementi

$$
f_j = f(a_j) = n_j/n 
$$

Le frequenze sono sempre comprese tra 0 e 1 e la loro somma fa 1. Per ottenere le frequenze relative basta aggiungere normalize=True: `value_counts(normalize=True).sort_index()`

## Barplot e Stackplot

A differenza del barplot, nello stackplot le colonne vengono impilate una sull'altra basta aggiungere stacked=True quando effettuiamo il plot

## Grafici a torta

Si utilizzano quando non abbiamo un ordinamento preferenziale, solitamente è meglio utilzzare i bar plot, utile nel caso delle proprozioni